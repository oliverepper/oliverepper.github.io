<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iOS on oliep</title>
    <link>https://oliverepper.github.io/tags/ios/</link>
    <description>Recent content in iOS on oliep</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 08 May 2020 09:41:00 +0200</lastBuildDate>
    
	<atom:link href="https://oliverepper.github.io/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to create a self sizing gauge component in SwiftUI</title>
      <link>https://oliverepper.github.io/posts/how-to-create-a-self-sizing-gauge-componen-in-swiftui/</link>
      <pubDate>Fri, 08 May 2020 09:41:00 +0200</pubDate>
      
      <guid>https://oliverepper.github.io/posts/how-to-create-a-self-sizing-gauge-componen-in-swiftui/</guid>
      <description>&lt;p&gt;SwiftUI is really great and building custom UI is actually pretty straight forward. Let&amp;rsquo;s use &lt;em&gt;function builders&lt;/em&gt; and &lt;em&gt;preference keys&lt;/em&gt; to build a component that looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://oliverepper.github.io/images/GaugeTests_lightmode.png&#34; alt=&#34;gauges&#34;&gt;&lt;/p&gt;
&lt;p&gt;The gauge features a center view that the user can either provide or the gauge will automatically show a text presenting it&amp;rsquo;s value.
So once we have our gauge component ready it can be used like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Simplest use possible, the Gauge will construct a centerView that shows: &amp;#39;\(value) %&amp;#39;.&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// To prevent constant resizings when passing in other values the centerView width is calculated&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// from the string: &amp;#39;100 %&amp;#39;&lt;/span&gt;
Gauge(value: value)

&lt;span style=&#34;color:#75715e&#34;&gt;// provide your own centerView.&lt;/span&gt;
Gauge(value: value) {
    Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;This is a fixed text&amp;#34;&lt;/span&gt;)
}

&lt;span style=&#34;color:#75715e&#34;&gt;// use an image&lt;/span&gt;
Gauge(value: value) {
    Image(systemName: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;headphones&amp;#34;&lt;/span&gt;)
        .resizable()
        .frame(width: &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;, height: &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The gauge will automatically adjust its size depending on the size of the center view.&lt;/p&gt;
&lt;h2 id=&#34;how-is-this-build&#34;&gt;How is this build?&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SwiftUI&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Gauge&lt;/span&gt;&amp;lt;T&amp;gt;: View &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; T: View {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; centerView: T
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value: Double
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; thickness: CGFloat = &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; scale: CGFloat = &lt;span style=&#34;color:#ae81ff&#34;&gt;1.777&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; gradient = AngularGradient(
        gradient: Gradient(
            colors: [
                .red,
                .green
            ]
        ),
        center: .center
    )
    
    @State &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; diameter: CGFloat = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(value: Double, @GaugeBuilder builder: () -&amp;gt; T) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.value = value
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.centerView = builder()
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; body: some View {
        ZStack {
            centerView.background(
                GeometryReader { proxy &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
                    Color.clear.preference(key: GaugeWidthPreferenceKey.&lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;, value: proxy.size.width)
                }
            )
            Group {
                Circle()
                    .stroke(Color.primary.opacity(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;), style: .&lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(lineWidth: thickness&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;scale, dash: [&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]))
                Circle()
                    .trim(from: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, to: CGFloat(value&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;))
                    .stroke(gradient, style: .&lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(lineWidth: thickness))
            }
            .padding(thickness&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
            .rotationEffect(.degrees(&lt;span style=&#34;color:#ae81ff&#34;&gt;90&lt;/span&gt;))
            .frame(width: diameter, height: diameter)
        }.onPreferenceChange(GaugeWidthPreferenceKey.&lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;) { width &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.diameter = width &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.scale
        }
    }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;extension&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Gauge&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; T == ZStack&amp;lt;TupleView&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(Text, Text)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(value: Double) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.value = value
        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.centerView = ZStack {
            Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100 %&amp;#34;&lt;/span&gt;).foregroundColor(.clear)
            Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;value, specifier: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%.0f&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; %&amp;#34;&lt;/span&gt;)
        }
    }
}

@_functionBuilder
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GaugeBuilder&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;buildBlock&lt;/span&gt;&amp;lt;T: View&amp;gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;_&lt;/span&gt; centerView: T) -&amp;gt; T {
        centerView
    }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GaugeWidthPreferenceKey&lt;/span&gt;: PreferenceKey {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;typealias&lt;/span&gt; Value = CGFloat
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; defaultValue: CGFloat = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reduce&lt;/span&gt;(value: &lt;span style=&#34;color:#66d9ef&#34;&gt;inout&lt;/span&gt; CGFloat, nextValue: () -&amp;gt; CGFloat) {
        value = nextValue()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So that&amp;rsquo;s the complete thing.  There are a few things worth mentioning.&lt;/p&gt;
&lt;h3 id=&#34;function-builder&#34;&gt;Function Builder&lt;/h3&gt;
&lt;p&gt;This is the magic behind the nice SwiftUI DSL. The &lt;code&gt;buildBlock&lt;/code&gt; function returns what gets passed as the trailing closure to the Gauge. So instead of this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;Gauge(value: value, centerView: Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;value&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; %&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;you can write:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;Gauge(value: value) {
    Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;value&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; %&amp;#34;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;preference-key&#34;&gt;Preference Key&lt;/h3&gt;
&lt;p&gt;In SwiftUI preference keys provide the possibility for a child view to pass values up to it&amp;rsquo;s ancestors. While &lt;code&gt;@Environment&lt;/code&gt;-objects are visible to child views, &lt;code&gt;PreferenceKeys&lt;/code&gt; are visible to parents.
What we want to achive is that the Gauge knows the width of it&amp;rsquo;s &lt;code&gt;centerView&lt;/code&gt; and adjusts the circles accordingly. So we add the &lt;code&gt;.background&lt;/code&gt;-modifier to the &lt;code&gt;centerView&lt;/code&gt; and fill it&amp;rsquo;s background with a transparent color. We use the &lt;code&gt;GeometryReader&lt;/code&gt;&#39;s proxy to get the size of the invisible Color and save that in the &lt;code&gt;GaugeWidthPreferenceKey&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we can use the &lt;code&gt;.onPreferenceChange&lt;/code&gt;-modifier on the outer ZStack to calculate the diameter of our circles. Since diamater is a &lt;code&gt;@State&lt;/code&gt;-property the body property of the Gauge will be evaluated and our circles are drawn with the desired diameter. Very cool!&lt;/p&gt;
&lt;h3 id=&#34;providing-a-default-center-view&#34;&gt;Providing a default center view&lt;/h3&gt;
&lt;p&gt;There&amp;rsquo;s one more thing required to make the Gauge work without the need to provide a centerView. We need an initializer takes only the value as an argument. This can be done with an extension of the Gauge using conditional conformance.&lt;/p&gt;
&lt;h3 id=&#34;why-conformance-to-zstacktupleviewtext-text&#34;&gt;Why conformance to &lt;code&gt;ZStack&amp;lt;TupleView&amp;lt;(Text, Text)&amp;gt;&amp;gt;&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;In order to prevent the Gauge to change it&amp;rsquo;s size with every different value between 0 and 100 % I build a default centerView that has the invisible string &amp;ldquo;100 %&amp;rdquo; and centered on top of that the string representing the actual value. So the &lt;code&gt;centerView&lt;/code&gt; will always have the same width.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A deprecated way to save Codables — but why?</title>
      <link>https://oliverepper.github.io/posts/a-deprecated-way-to-save-codables/</link>
      <pubDate>Fri, 21 Feb 2020 09:41:00 +0200</pubDate>
      
      <guid>https://oliverepper.github.io/posts/a-deprecated-way-to-save-codables/</guid>
      <description>&lt;p&gt;I was looking for a way to save a lot of Codables that emerge over a potentially long timespan. Just keeping them in memory looked like the obvious thing to do but I wanted something failsafe and persistent.&lt;/p&gt;
&lt;p&gt;Saving a Codable to a file in Swift couldn’t be easier: &lt;code&gt;JSONEncoder.encode(T)&lt;/code&gt; returns &lt;code&gt;Data&lt;/code&gt;. That can be written to an &lt;code&gt;URL&lt;/code&gt; via &lt;code&gt;write(to: URL)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if I want to append?&lt;/p&gt;
&lt;p&gt;I for sure don’t want to load the data from a file, decode it into a JSON array, append the new Codable to the array, encode the array to data and then use that data to overwrite the file.&lt;/p&gt;
&lt;p&gt;I do the following:&lt;/p&gt;
&lt;p&gt;An instance of &lt;code&gt;CodableFileBuffer&amp;lt;T&amp;gt;&lt;/code&gt; keeps an open FileHandle on an URL and whenever I call &lt;code&gt;append(codable)&lt;/code&gt; on that buffer it encodes to data and writes that data to the file handle.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;_&lt;/span&gt; codable: T) {
    &lt;span style=&#34;color:#75715e&#34;&gt;// encode codable&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;? encoder.encode(codable) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cannot encode &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;codable&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// write to FileHandle&lt;/span&gt;
    fileHandle.write(data)
    fileHandle.write(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;.data(using: .utf8)&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;)

    &lt;span style=&#34;color:#75715e&#34;&gt;// log&lt;/span&gt;
    os_log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Did append codable to CodableFileBuffer at: %@&amp;#34;&lt;/span&gt;, log: OSLog.CodableFileBuffer, type: .debug, fileURL.lastPathComponent)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This could use a little more error handling but it is just for demo purpose. Bare with me.&lt;/p&gt;
&lt;p&gt;The only thing not completely obvious happens on line 9. This ist just the comma that is required to form a JSON array. When I create the FileHandle I immediately write an opening square bracket to the file and the &lt;code&gt;retrieve() -&amp;gt; [Codable]&lt;/code&gt; function appends the closing square-bracket to the data before it passes it to the JSONDecoder.&lt;/p&gt;
&lt;p&gt;So the files content loos like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;// after initializing
[
  
// after writing the first codable
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},
 
// after writing the second codable
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},{&amp;#34;id&amp;#34;:2, &amp;#34;key&amp;#34;: &amp;#34;another_value&amp;#34;},

// the data that gets passed to the JSONDecoder looks like this
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},{&amp;#34;id&amp;#34;:2, &amp;#34;key&amp;#34;: &amp;#34;another_value&amp;#34;},]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I know the trailing comma is ugly and no valid json. It would be an easy fix but actually the &lt;code&gt;JSONDecoder&lt;/code&gt; is pretty forgiving, here.&lt;/p&gt;
&lt;p&gt;So what do we have now?&lt;/p&gt;
&lt;p&gt;We have a Buffer that can be used like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyCodable&lt;/span&gt;: Codable {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; id: Int
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; key: String
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; buffer = CodableFileBuffer&amp;lt;MyCodable&amp;gt;()

buffer.append(MyCodable(id: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, key: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;value_one&amp;#34;&lt;/span&gt;))
buffer.append(MyCodable(id: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, key: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;another_value&amp;#34;&lt;/span&gt;))

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; myCodables = buffer.retrieve()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Neat, isn’t it?&lt;/p&gt;
&lt;p&gt;I use it to append thousands of Codables and it works pretty nice, so far. I measured it with instruments using tens of thousands to Codables. And I use it on real devices running for days.&lt;/p&gt;
&lt;p&gt;Here’s the complete thing:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/oliverepper/CodableFileBuffer&#34;&gt;CodeableFileBuffer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So what’s next?&lt;/p&gt;
&lt;p&gt;I have a few questions I’d like to discuss:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why is &lt;code&gt;FileHandle.write&lt;/code&gt; deprecated? It sure doesn’t look swifty. It can throw exceptions without beeing marked as throwing.&lt;/li&gt;
&lt;li&gt;How are we supposed to replace this? How does the &lt;code&gt;writeabilityHandler&lt;/code&gt; work? Can anyone provide an example?&lt;/li&gt;
&lt;li&gt;What do you think? I guess there must be other or better ways to buffer Codables on disk.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I’d really appreciate your ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to use CoreData inside xcframework</title>
      <link>https://oliverepper.github.io/posts/how-to-use-coredata-inside-xcframework/</link>
      <pubDate>Thu, 20 Feb 2020 09:41:00 +0200</pubDate>
      
      <guid>https://oliverepper.github.io/posts/how-to-use-coredata-inside-xcframework/</guid>
      <description>&lt;p&gt;The company I work for distributes a binary framework that records data on an iPhone. Since I am in charge of that framework and I enjoy working with CoreData I wanted to use it to store the collected data.
Sadly my first attempt of doing this resulted in an error when I tried to use the framework inside an actual app.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@NSManaged not allowed on computed properties&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is coming from the generated .swiftinterface file so there is not much you can do about it.
With a little research and some help I found the good news:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apple/swift/pull/27676&#34;&gt;[ModuleInterfaces] Don&amp;rsquo;t diagnose @NSManaged properties with accessors #27676&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So there is a fix 🤗&lt;/p&gt;
&lt;h2 id=&#34;get-the-fix&#34;&gt;Get the fix&lt;/h2&gt;
&lt;p&gt;At the time of writing all you need to do is to download and use the Xcode beta (11.4) which comes with a newer version of the Swift compiler that already has the fix.
The rest is then pretty straight forward.&lt;/p&gt;
&lt;h2 id=&#34;create-the-datamodel&#34;&gt;Create the DataModel&lt;/h2&gt;
&lt;p&gt;You can use File-&amp;gt;New and then search for „Data Model“ in the template chooser. I will call it `MyDataModel for demo purpose.&lt;/p&gt;
&lt;h2 id=&#34;create-an-instance-of-nspersistentcontainer-in-your-framework-code&#34;&gt;Create an instance of NSPersistentContainer in your framework code&lt;/h2&gt;
&lt;p&gt;This might not be obvious at first, but it is not hard. When you create an app with core data you get the following code inside your AppDelegate:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;lazy&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; persistentContainer: NSPersistentContainer = {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; container = NSPersistentContainer(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DemoApp&amp;#34;&lt;/span&gt;)
  container.loadPersistentStores(completionHandler: { (storeDescription, error) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; error = error &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; NSError? {
      fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unresolved error &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error.userInfo&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
    }
  })
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; container
}()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;While the initializer &lt;code&gt;init(name: String)&lt;/code&gt; of &lt;code&gt;NSPersistentContainer&lt;/code&gt; is pretty convenient we can’t use it, because in the context of the running app it simply couldn’t find the model. We need to use &lt;code&gt;init(name: String, managedObjectModel: NSManagedObjectModel)&lt;/code&gt; to get the container. &lt;code&gt;NSManagedObjectModel&lt;/code&gt; has an initializer that takes an &lt;code&gt;URL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So update the above to this instead:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;lazy&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; persistentContainer: NSPersistentContainer = {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; modelName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MyDataModel&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; modelDir = Bundle(&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;: type(of: &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;)).url(forResource: modelName, withExtension: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;momd&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { fatalError() }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mom = NSManagedObjectModel(contentsOf: modelDir) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { fatalError() }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; container = NSPersistentContainer(name: modelName, managedObjectModel: mom)
    container.loadPersistentStores(completionHandler: { (storeDescription, error) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; error = error &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; NSError? {
            fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unresolved error &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error.userInfo&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
        }
    })
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; container
}()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;final&#34;&gt;Final&lt;/h2&gt;
&lt;p&gt;Please be aware, that a CoreData App has a &lt;code&gt;saveContext&lt;/code&gt; function that gets automatically called by the &lt;code&gt;SceneDelegate&lt;/code&gt; when the scene enters the background. If you want to use CoreData in a framework I guess you’ll decide when to save by yourself, anyways.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
