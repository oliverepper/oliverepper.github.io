<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on oliep</title>
    <link>https://oliverepper.github.io/tags/swift/</link>
    <description>Recent content in Swift on oliep</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 21 Feb 2020 09:41:00 +0200</lastBuildDate>
    
	<atom:link href="https://oliverepper.github.io/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A deprecated way to saves Codables â€” but why?</title>
      <link>https://oliverepper.github.io/posts/a-deprecated-way-to-save-codables/</link>
      <pubDate>Fri, 21 Feb 2020 09:41:00 +0200</pubDate>
      
      <guid>https://oliverepper.github.io/posts/a-deprecated-way-to-save-codables/</guid>
      <description>&lt;p&gt;I was looking for a way to save a lot of Codables that emerge over a potentially long timespan. Just keeping them in memory looked like the obvious thing to do but I wanted something failsafe and persistent.&lt;/p&gt;
&lt;p&gt;Saving a Codable to a file in Swift couldnâ€™t be easier: &lt;code&gt;JSONEncoder.encode(T)&lt;/code&gt; returns &lt;code&gt;Data&lt;/code&gt;. That can be written to an &lt;code&gt;URL&lt;/code&gt; via &lt;code&gt;write(to: URL)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if I want to append?&lt;/p&gt;
&lt;p&gt;I for sure donâ€™t want to load the data from a file, decode it into a JSON array, append the new Codable to the array, encode the array to data and then use that data to overwrite the file.&lt;/p&gt;
&lt;p&gt;I do the following:&lt;/p&gt;
&lt;p&gt;An instance of &lt;code&gt;CodableFileBuffer&amp;lt;T&amp;gt;&lt;/code&gt; keeps an open FileHandle on an URL and whenever I call &lt;code&gt;append(codable)&lt;/code&gt; on that buffer it encodes to data and writes that data to the file handle.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;_&lt;/span&gt; codable: T) {
    &lt;span style=&#34;color:#75715e&#34;&gt;// encode codable&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;? encoder.encode(codable) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cannot encode &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;codable&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// write to FileHandle&lt;/span&gt;
    fileHandle.write(data)
    fileHandle.write(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;.data(using: .utf8)&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;)

    &lt;span style=&#34;color:#75715e&#34;&gt;// log&lt;/span&gt;
    os_log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Did append codable to CodableFileBuffer at: %@&amp;#34;&lt;/span&gt;, log: OSLog.CodableFileBuffer, type: .debug, fileURL.lastPathComponent)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This could use a little more error handling but it is just for demo purpose. Bare with me.&lt;/p&gt;
&lt;p&gt;The only thing not completely obvious happens on line 9. This ist just the comma that is required to form a JSON array. When I create the FileHandle I immediately write an opening square bracket to the file and the &lt;code&gt;retrieve() -&amp;gt; [Codable]&lt;/code&gt; function appends the closing square-bracket to the data before it passes it to the JSONDecoder.&lt;/p&gt;
&lt;p&gt;So the files content loos like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;// after initializing
[
  
// after writing the first codable
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},
 
// after writing the second codable
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},{&amp;#34;id&amp;#34;:2, &amp;#34;key&amp;#34;: &amp;#34;another_value&amp;#34;},

// the data that gets passed to the JSONDecoder looks like this
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},{&amp;#34;id&amp;#34;:2, &amp;#34;key&amp;#34;: &amp;#34;another_value&amp;#34;},]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I know the trailing comma is ugly and no valid json. It would be an easy fix but actually the &lt;code&gt;JSONDecoder&lt;/code&gt; is pretty forgiving, here.&lt;/p&gt;
&lt;p&gt;So what do we have now?&lt;/p&gt;
&lt;p&gt;We have a Buffer that can be used like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyCodable&lt;/span&gt;: Codable {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; id: Int
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; key: String
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; buffer = CodableFileBuffer&amp;lt;MyCodable&amp;gt;()

buffer.append(MyCodable(id: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, key: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;value_one&amp;#34;&lt;/span&gt;))
buffer.append(MyCodable(id: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, key: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;another_value&amp;#34;&lt;/span&gt;))

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; myCodables = buffer.retrieve()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Neat, isnâ€™t it?&lt;/p&gt;
&lt;p&gt;I use it to append thousands of Codables and it works pretty nice, so far. I measured it with instruments using tens of thousands to Codables. And I use it on real devices running for days.&lt;/p&gt;
&lt;p&gt;Hereâ€™s the complete thing:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/oliverepper/CodableFileBuffer&#34;&gt;CodeableFileBuffer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So whatâ€™s next?&lt;/p&gt;
&lt;p&gt;I have a few questions Iâ€™d like to discuss:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why is &lt;code&gt;FileHandle.write&lt;/code&gt; deprecated? It sure doesnâ€™t look swifty. It can throw exceptions without beeing marked as throwing.&lt;/li&gt;
&lt;li&gt;How are we supposed to replace this? How does the &lt;code&gt;writeabilityHandler&lt;/code&gt; work? Can anyone provide an example?&lt;/li&gt;
&lt;li&gt;What do you think? I guess there must be other or better ways to buffer Codables on disk.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Iâ€™d really appreciate your ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to use CoreData inside xcframework</title>
      <link>https://oliverepper.github.io/posts/how-to-use-coredata-inside-xcframework/</link>
      <pubDate>Thu, 20 Feb 2020 09:41:00 +0200</pubDate>
      
      <guid>https://oliverepper.github.io/posts/how-to-use-coredata-inside-xcframework/</guid>
      <description>&lt;p&gt;The company I work for distributes a binary framework that records data on an iPhone. Since I am in charge of that framework and I enjoy working with CoreData I wanted to use it to store the collected data.
Sadly my first attempt of doing this resulted in an error when I tried to use the framework inside an actual app.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@NSManaged not allowed on computed properties&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is coming from the generated .swiftinterface file so there is not much you can do about it.
With a little research and some help I found the good news:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apple/swift/pull/27676&#34;&gt;[ModuleInterfaces] Don&amp;rsquo;t diagnose @NSManaged properties with accessors #27676&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So there is a fix ðŸ¤—&lt;/p&gt;
&lt;h2 id=&#34;get-the-fix&#34;&gt;Get the fix&lt;/h2&gt;
&lt;p&gt;At the time of writing all you need to do is to download and use the Xcode beta (11.4) which comes with a newer version of the Swift compiler that already has the fix.
The rest is then pretty straight forward.&lt;/p&gt;
&lt;h2 id=&#34;create-the-datamodel&#34;&gt;Create the DataModel&lt;/h2&gt;
&lt;p&gt;You can use File-&amp;gt;New and then search for â€žData Modelâ€œ in the template chooser. I will call it `MyDataModel for demo purpose.&lt;/p&gt;
&lt;h2 id=&#34;create-an-instance-of-nspersistentcontainer-in-your-framework-code&#34;&gt;Create an instance of NSPersistentContainer in your framework code&lt;/h2&gt;
&lt;p&gt;This might not be obvious at first, but it is not hard. When you create an app with core data you get the following code inside your AppDelegate:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;lazy&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; persistentContainer: NSPersistentContainer = {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; container = NSPersistentContainer(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DemoApp&amp;#34;&lt;/span&gt;)
  container.loadPersistentStores(completionHandler: { (storeDescription, error) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; error = error &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; NSError? {
      fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unresolved error &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error.userInfo&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
    }
  })
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; container
}()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;While the initializer &lt;code&gt;init(name: String)&lt;/code&gt; of &lt;code&gt;NSPersistentContainer&lt;/code&gt; is pretty convenient we canâ€™t use it, because in the context of the running app it simply couldnâ€™t find the model. We need to use &lt;code&gt;init(name: String, managedObjectModel: NSManagedObjectModel)&lt;/code&gt; to get the container. &lt;code&gt;NSManagedObjectModel&lt;/code&gt; has an initializer that takes an &lt;code&gt;URL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So update the above to this instead:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;lazy&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; persistentContainer: NSPersistentContainer = {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; modelName = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MyDataModel&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; modelDir = Bundle(&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;: type(of: &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;)).url(forResource: modelName, withExtension: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;momd&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { fatalError() }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mom = NSManagedObjectModel(contentsOf: modelDir) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { fatalError() }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; container = NSPersistentContainer(name: modelName, managedObjectModel: mom)
    container.loadPersistentStores(completionHandler: { (storeDescription, error) &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; error = error &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; NSError? {
            fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unresolved error &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error.userInfo&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
        }
    })
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; container
}()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;final&#34;&gt;Final&lt;/h2&gt;
&lt;p&gt;Please be aware, that a CoreData App has a &lt;code&gt;saveContext&lt;/code&gt; function that gets automatically called by the &lt;code&gt;SceneDelegate&lt;/code&gt; when the scene enters the background. If you want to use CoreData in a framework I guess youâ€™ll decide when to save by yourself, anyways.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
