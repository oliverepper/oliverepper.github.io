<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codables on oliep</title>
    <link>https://oliverepper.github.io/tags/codables/</link>
    <description>Recent content in Codables on oliep</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 21 Feb 2020 09:41:00 +0200</lastBuildDate>
    
	<atom:link href="https://oliverepper.github.io/tags/codables/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A deprecated way to saves Codables — but why?</title>
      <link>https://oliverepper.github.io/posts/a-deprecated-way-to-save-codables/</link>
      <pubDate>Fri, 21 Feb 2020 09:41:00 +0200</pubDate>
      
      <guid>https://oliverepper.github.io/posts/a-deprecated-way-to-save-codables/</guid>
      <description>&lt;p&gt;I was looking for a way to save a lot of Codables that emerge over a potentially long timespan. Just keeping them in memory looked like the obvious thing to do but I wanted something failsafe and persistent.&lt;/p&gt;
&lt;p&gt;Saving a Codable to a file in Swift couldn’t be easier: &lt;code&gt;JSONEncoder.encode(T)&lt;/code&gt; returns &lt;code&gt;Data&lt;/code&gt;. That can be written to an &lt;code&gt;URL&lt;/code&gt; via &lt;code&gt;write(to: URL)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if I want to append?&lt;/p&gt;
&lt;p&gt;I for sure don’t want to load the data from a file, decode it into a JSON array, append the new Codable to the array, encode the array to data and then use that data to overwrite the file.&lt;/p&gt;
&lt;p&gt;I do the following:&lt;/p&gt;
&lt;p&gt;An instance of &lt;code&gt;CodableFileBuffer&amp;lt;T&amp;gt;&lt;/code&gt; keeps an open FileHandle on an URL and whenever I call &lt;code&gt;append(codable)&lt;/code&gt; on that buffer it encodes to data and writes that data to the file handle.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;_&lt;/span&gt; codable: T) {
    &lt;span style=&#34;color:#75715e&#34;&gt;// encode codable&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; data = &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;? encoder.encode(codable) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        fatalError(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cannot encode &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;codable&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// write to FileHandle&lt;/span&gt;
    fileHandle.write(data)
    fileHandle.write(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;.data(using: .utf8)&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;)

    &lt;span style=&#34;color:#75715e&#34;&gt;// log&lt;/span&gt;
    os_log(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Did append codable to CodableFileBuffer at: %@&amp;#34;&lt;/span&gt;, log: OSLog.CodableFileBuffer, type: .debug, fileURL.lastPathComponent)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This could use a little more error handling but it is just for demo purpose. Bare with me.&lt;/p&gt;
&lt;p&gt;The only thing not completely obvious happens on line 9. This ist just the comma that is required to form a JSON array. When I create the FileHandle I immediately write an opening square bracket to the file and the &lt;code&gt;retrieve() -&amp;gt; [Codable]&lt;/code&gt; function appends the closing square-bracket to the data before it passes it to the JSONDecoder.&lt;/p&gt;
&lt;p&gt;So the files content loos like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;// after initializing
[
  
// after writing the first codable
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},
 
// after writing the second codable
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},{&amp;#34;id&amp;#34;:2, &amp;#34;key&amp;#34;: &amp;#34;another_value&amp;#34;},

// the data that gets passed to the JSONDecoder looks like this
[{&amp;#34;id&amp;#34;:1, &amp;#34;key&amp;#34;: &amp;#34;value_one&amp;#34;},{&amp;#34;id&amp;#34;:2, &amp;#34;key&amp;#34;: &amp;#34;another_value&amp;#34;},]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I know the trailing comma is ugly and no valid json. It would be an easy fix but actually the &lt;code&gt;JSONDecoder&lt;/code&gt; is pretty forgiving, here.&lt;/p&gt;
&lt;p&gt;So what do we have now?&lt;/p&gt;
&lt;p&gt;We have a Buffer that can be used like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyCodable&lt;/span&gt;: Codable {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; id: Int
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; key: String
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; buffer = CodableFileBuffer&amp;lt;MyCodable&amp;gt;()

buffer.append(MyCodable(id: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, key: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;value_one&amp;#34;&lt;/span&gt;))
buffer.append(MyCodable(id: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, key: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;another_value&amp;#34;&lt;/span&gt;))

&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; myCodables = buffer.retrieve()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Neat, isn’t it?&lt;/p&gt;
&lt;p&gt;I use it to append thousands of Codables and it works pretty nice, so far. I measured it with instruments using tens of thousands to Codables. And I use it on real devices running for days.&lt;/p&gt;
&lt;p&gt;Here’s the complete thing:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/oliverepper/CodableFileBuffer&#34;&gt;CodeableFileBuffer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So what’s next?&lt;/p&gt;
&lt;p&gt;I have a few questions I’d like to discuss:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why is &lt;code&gt;FileHandle.write&lt;/code&gt; deprecated? It sure doesn’t look swifty. It can throw exceptions without beeing marked as throwing.&lt;/li&gt;
&lt;li&gt;How are we supposed to replace this? How does the &lt;code&gt;writeabilityHandler&lt;/code&gt; work? Can anyone provide an example?&lt;/li&gt;
&lt;li&gt;What do you think? I guess there must be other or better ways to buffer Codables on disk.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I’d really appreciate your ideas.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
