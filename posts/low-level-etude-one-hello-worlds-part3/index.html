<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="oliep"/><link rel="canonical" href="https://oliver-epper.de/posts/low-level-etude-one-hello-worlds-part3"/><meta name="twitter:url" content="https://oliver-epper.de/posts/low-level-etude-one-hello-worlds-part3"/><meta name="og:url" content="https://oliver-epper.de/posts/low-level-etude-one-hello-worlds-part3"/><title>Low Level Etude One – Hello Worlds (Part 3) | oliep</title><meta name="twitter:title" content="Low Level Etude One – Hello Worlds (Part 3) | oliep"/><meta name="og:title" content="Low Level Etude One – Hello Worlds (Part 3) | oliep"/><meta name="description" content="Connect a few dots"/><meta name="twitter:description" content="Connect a few dots"/><meta name="og:description" content="Connect a few dots"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to oliep"/></head><body><div class="wrapper"><header><div class="container"><nav class="navigation"><a href="/">oliep</a><ul><li><a href="/posts">Posts</a></li><li><a href="/apps">Apps</a></li><li><a href="https://golf.oliver-epper.de">Golf</a></li><li><a href="/about">About</a></li></ul></nav></div></header><main class="grow"><div class="container"><article><h1>Low Level Etude One – Hello Worlds (Part 3)</h1><div class="item-metadata"><ul><li><span class="fas fa-calendar"></span>4. August 2022</li><li><span class="fas fa-clock"></span>2-minute read</li></ul><div class="taglist"><span class="fas fa-tags"></span><a href="/tags/assembler">Assembler</a>&middot;<a href="/tags/arm64">ARM64</a>&middot;<a href="/tags/apple-silicon">Apple Silicon</a>&middot;<a href="/tags/low-level">Low Level</a>&middot;<a href="/tags/etude">Etude</a></div></div><h2>Hello World - bare metal</h2><p><a href="https://oliver-epper.de/posts/low-level-etude-one-hello-worlds-part2/">Part 2</a></p><p>To finish this first etude lets demo one more Hello World program. There are many options, but I stumbled upon another great resource on the internet that's worth mentioning: The <a href="https://wiki.osdev.org/Main_Page">OSDev.org Wiki</a>. They have a wonderful Hello World example here: <a href="https://wiki.osdev.org/QEMU_AArch64_Virt_Bare_Bones">QEMU AArch64 Virt Bare Bones</a>.</p><p>They do the following:</p><pre><code><div class="highlight"><span></span><span class="na">.globl</span>            <span class="no">_start</span>

<span class="nl">_start:</span>
                  <span class="nf">ldr</span> <span class="no">x30</span><span class="p">,</span> <span class="err">=</span><span class="no">stack_top</span>
                  <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">x30</span>
                  <span class="nf">bl</span> <span class="no">kmain</span>
                  <span class="nf">b</span> <span class="p">.</span>
</div></code></pre><p>This is the boot code. It basically sets up the stack and jumps into the <code>kmain</code> function. If that returns the last line will loop forever.</p><pre><code><div class="highlight"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x09000000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">putchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">uart</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
            <span class="n">s</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</div></code></pre><p>There's your <em>kernel</em>. Since we are no longer in a hosted environment we need to build a <code>print</code> function ourselfs. Don't forget the volatile keyword if you talk to memory mapped hardware resources, otherwise the compiler will optimize away every assignment but the last.</p><pre><code><div class="highlight"><span></span><span class="n">ENTRY</span><span class="p">(</span><span class="n">_start</span><span class="p">)</span>
<span class="n">SECTIONS</span> <span class="p">{</span>
      <span class="p">.</span> <span class="p">=</span> <span class="mh">0x40000000</span><span class="p">;</span>
      <span class="p">.</span><span class="n">startup</span> <span class="p">.</span> <span class="p">:</span> <span class="p">{</span> <span class="n">boot</span><span class="p">.</span><span class="n">o</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">text</span> <span class="p">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">text</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">data</span> <span class="p">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">bss</span> <span class="p">:</span> <span class="p">{</span> <span class="o">*</span><span class="p">(.</span><span class="n">bss</span> <span class="n">COMMON</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span> <span class="p">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
      <span class="p">.</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span> <span class="cm">/* 4kb of stack memory */</span>
      <span class="n">stack_top</span> <span class="p">=</span> <span class="p">.;</span>
<span class="p">}</span>
</div></code></pre><p>This is the linker configuration that helps produce the <code>ELF</code> file that we need. You can install the required compiler and tools via <code>brew install aarch-elf-gcc qemu</code>.</p><p>Build the kernel via:</p><pre><code><div class="highlight"><span></span>aarch64-elf-as -o boot.o boot.s                                   
aarch64-elf-gcc -ffreestanding -c kernel.c -o kernel.o            
aarch64-elf-ld -nostdlib -Tlinker.ld boot.o kernel.o -o kernel.elf
</div></code></pre><p>And run it via:</p><pre><code><div class="highlight"><span></span>qemu-system-aarch64 -machine virt -cpu cortex-a57 -kernel kernel.elf -nographic
</div></code></pre><p>The OS Dev wiki examples ends here. If you tried it you have the qemu process running in an endless loop, now (<code>b .</code>). Let's try to fix that.</p><p>I have no clue (yet) how a real OS performs shutdown or reboot but we can use the semihosting interface <a href="https://developer.arm.com/documentation/dui0471/g/Bgbjjgij">What is semihosting?</a> of the ARM CPU to tell qemu that our software has finished execution. <a href="https://stackoverflow.com/questions/31990487/how-to-cleanly-exit-qemu-after-executing-bare-metal-program-without-user-interve/49930361#49930361">How to cleanly exit QEMU after executing bare metal program without user intervention?</a></p><pre><code><div class="highlight"><span></span><span class="na">.globl</span>            <span class="no">_start</span>


<span class="nl">shutdown:</span>
                  <span class="nf">mov</span> <span class="no">x0</span><span class="p">,</span> <span class="mi">#0</span><span class="no">x18</span>
                  <span class="nf">hlt</span> <span class="mi">0xf000</span>

<span class="nl">_start:</span>
                  <span class="nf">ldr</span> <span class="no">x30</span><span class="p">,</span> <span class="err">=</span><span class="no">stack_top</span>
                  <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">x30</span>
                  <span class="nf">bl</span> <span class="no">kmain</span>
                  <span class="nf">b</span> <span class="no">shutdown</span>
</div></code></pre><p>If I understand this right, the above makes qemu call SYS_exit through the semihosting interface on our behalf. Now we need to add the <code>-semihosting</code> option to qemu and indeed the process returns.</p></article></div></main><footer><div class="container"><div class="credits">Oliver Epper &middot; made with <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a> &middot;  inspired by <a href="https://github.com/luizdepra/hugo-coder" target="_blank">Coder</a> &middot; <a href="/feed.rss">RSS feed</a></div></div></footer></div><script src="https://kit.fontawesome.com/fd7cbf6928.js" crossorigin="anonmous"></script></body></html>