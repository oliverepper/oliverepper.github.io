<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="oliep"/><link rel="canonical" href="https://oliver-epper.de/posts/using-bsd-sockets-from-cpp"/><meta name="twitter:url" content="https://oliver-epper.de/posts/using-bsd-sockets-from-cpp"/><meta name="og:url" content="https://oliver-epper.de/posts/using-bsd-sockets-from-cpp"/><title>Using the BSD socket API from C++ | oliep</title><meta name="twitter:title" content="Using the BSD socket API from C++ | oliep"/><meta name="og:title" content="Using the BSD socket API from C++ | oliep"/><meta name="description" content="How I use the BSD socket API from C++"/><meta name="twitter:description" content="How I use the BSD socket API from C++"/><meta name="og:description" content="How I use the BSD socket API from C++"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to oliep"/></head><body><div class="wrapper"><header><div class="container"><nav class="navigation"><a href="/">oliep</a><ul><li><a href="/posts">Posts</a></li><li><a href="/apps">Apps</a></li><li><a href="https://golf.oliver-epper.de">Golf</a></li><li><a href="/about">About</a></li></ul></nav></div></header><main class="grow"><div class="container"><article><h1>Using the BSD socket API from C++</h1><div class="item-metadata"><ul><li><span class="fas fa-calendar"></span>1. Januar 2024</li><li><span class="fas fa-clock"></span>2-minute read</li></ul><div class="taglist"><span class="fas fa-tags"></span><a href="/tags/network">network</a>&middot;<a href="/tags/bsd">BSD</a>&middot;<a href="/tags/sockets">sockets</a>&middot;<a href="/tags/cpp">cpp</a></div></div><h2>Setting the stage</h2><p>A lot of the POSIX API functions come in pairs: <code>getifaddrs</code> and <code>freeifaddrs</code> or <code>getaddrinfo</code> and <code>freeaddrinfo</code>. Both take the address of a pointer as an out parameter and, if successful, make that point to a linked-list allocated on the free-store. This memory-resources must be freed via the <code>free</code>-functions.</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">demo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ifaddrs</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getifaddrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">error</span><span class="p">{</span><span class="n">gai_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">)};</span>

<span class="w">    </span><span class="c1">// use result</span>

<span class="w">    </span><span class="n">freeifaddrs</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</div></code></pre><p>This is not a good solution, because it's hard to make sure that the free-function is called and called only once. In C++ smart-pointer provides a handle to a memory allocation and thus can guarantee the release of the resource.</p><h2>Using a smart-pointer for the out parameter</h2><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">demo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">deleter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">ifaddrs</span><span class="w"> </span><span class="o">*</span><span class="n">ia</span><span class="p">){</span><span class="w"> </span><span class="n">freeifaddrs</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ifaddrs</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">deleter</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ifaddrs</span><span class="w"> </span><span class="o">*</span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getifaddrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">error</span><span class="p">{</span><span class="n">gai_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">)};</span>
<span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// use result</span>
<span class="p">}</span>
</div></code></pre><p>This is really nice. The smart-pointer handles the release of the allocated memory for us, now.</p><h2>Using C++ algorithms</h2><p>Since these POSIX functions provide linked-lists it would be very nice to provide an iterator that would make them usable with the STL algorithms.</p><h3>Linked-List-Iterator</h3><pre><code><div class="highlight"><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">linked_list_iterator</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">difference_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">ptrdiff_t</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">iterator_category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward_iterator_tag</span><span class="p">;</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_type</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_type</span><span class="o">&amp;</span><span class="p">;</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">Next</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">T</span><span class="o">*</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">linked_list_iterator</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">Next</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">current</span><span class="p">{</span><span class="n">ptr</span><span class="p">},</span><span class="w"> </span><span class="n">next</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="p">)}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="n">reference</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">pointer</span><span class="w"> </span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;**</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">linked_list_iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">++</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">linked_list_iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">linked_list_iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</div></code></pre><h3>Using count_if example</h3><pre><code><div class="highlight"><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">count_addresses</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">family</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">deleter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">ifaddrs</span><span class="w"> </span><span class="o">*</span><span class="n">ia</span><span class="p">){</span><span class="w"> </span><span class="n">freeifaddrs</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ifaddrs</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">deleter</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ifaddrs</span><span class="w"> </span><span class="o">*</span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getifaddrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">error</span><span class="p">{</span><span class="n">gai_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">)};</span>
<span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// use result</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linked_list_iterator</span><span class="o">&lt;</span><span class="n">ifaddrs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="n">ifaddrs</span><span class="w"> </span><span class="o">*</span><span class="n">ia</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">ia</span><span class="o">-&gt;</span><span class="n">ifa_next</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linked_list_iterator</span><span class="o">&lt;</span><span class="n">ifaddrs</span><span class="o">&gt;</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">begin</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">family</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ia</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">ia</span><span class="p">.</span><span class="n">ifa_addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">family</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="p">}</span>
</div></code></pre></article></div></main><footer><div class="container"><div class="credits">Oliver Epper &middot; made with <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a> &middot;  inspired by <a href="https://github.com/luizdepra/hugo-coder" target="_blank">Coder</a> &middot; <a href="/feed.rss">RSS feed</a></div></div></footer></div><script src="https://kit.fontawesome.com/fd7cbf6928.js" crossorigin="anonmous"></script></body></html>