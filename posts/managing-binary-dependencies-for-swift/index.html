<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="oliep"/><link rel="canonical" href="https://oliver-epper.de/posts/managing-binary-dependencies-for-swift"/><meta name="twitter:url" content="https://oliver-epper.de/posts/managing-binary-dependencies-for-swift"/><meta name="og:url" content="https://oliver-epper.de/posts/managing-binary-dependencies-for-swift"/><title>Managing binary dependencies for swift | oliep</title><meta name="twitter:title" content="Managing binary dependencies for swift | oliep"/><meta name="og:title" content="Managing binary dependencies for swift | oliep"/><meta name="description" content="Make PjSIP Project available for mutiple architectures and targets"/><meta name="twitter:description" content="Make PjSIP Project available for mutiple architectures and targets"/><meta name="og:description" content="Make PjSIP Project available for mutiple architectures and targets"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to oliep"/></head><body><div class="wrapper"><header><div class="container"><nav class="navigation"><a href="/">oliep</a><ul><li><a href="/posts">Posts</a></li><li><a href="/apps">Apps</a></li><li><a href="https://golf.oliver-epper.de">Golf</a></li><li><a href="/about">About</a></li></ul></nav></div></header><main class="grow"><div class="container"><article><h1>Managing binary dependencies for swift</h1><div class="item-metadata"><ul><li><span class="fas fa-calendar"></span>22. April 2022</li><li><span class="fas fa-clock"></span>4-minute read</li></ul><div class="taglist"><span class="fas fa-tags"></span><a href="/tags/pjsip">pjsip</a>&middot;<a href="/tags/pjproject">pjproject</a>&middot;<a href="/tags/cmake">cmake</a>&middot;<a href="/tags/pkgconfig">pkg-config</a>&middot;<a href="/tags/swift">Swift</a>&middot;<a href="/tags/c">C</a>&middot;<a href="/tags/c">C++</a></div></div><h2>The problem</h2><p>One of the core dependencies for my employer is the <a href="https://www.pjsip.org">PjSIP Project</a>. As many others libraries it is written in C for maximum compatibility. Modernizing parts of our stack I wanted a single swift package <code>PjSIP</code> that I can rely on with no further fiddeling.</p><p>To be useable it needed to support at least the following environments: MacOS (Intel and Apple Silicon), iPhoneOS and iPhone Simulator running on Apple Silicon. PjSIP project is a complex library to begin with and the above are four builds, already. So we want to build them in a controlled fashion and use as binary dependency.</p><h2>xcframework</h2><p>Xcframeworks handle the above well. They can contain libraries for multiple platforms (and variants!) and the libraries can even be fat-libs so we get everything we need.</p><p>So the first step was to create an xcframework. You can see how it's done here <a href="https://github.com/oliverepper/pjproject-apple-platforms/blob/main/start.sh">pjproject-apple-platforms</a> beginning at around line 150 <code>cat &lt;&lt; 'END' &gt; pjproject/build_apple_platforms.sh</code>. Basically we build the object files and pack them together with <code>libtool</code>.</p><p>Xcframeworks are simple: The build system sees them, reads their <code>Info.plist</code> and copies the appropriate library to your build folder before the build. So speaking in C-lingo <code>-lpjproject</code> will be happy.</p><h2>Headers vs Modules</h2><p>If we would start a multiplatform app now and drop the xcframwork into the app the linker would be able to link against our <code>libpjproject</code> and see the <code>_pj_init</code> symbol, for example. But Swift still can't see any of the symbols from PjSIP project. In Xcode you could create a Bridging-Header and configure the include paths.</p><p>Since our goal is a neat Swift Package we create one for PjSIP project including the following:</p><pre><code><div class="highlight"><span></span><span class="p">.</span><span class="n">systemLibrary</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;Cpjproject&quot;</span><span class="p">,</span> <span class="n">pkgConfig</span><span class="p">:</span> <span class="s">&quot;pjproject-apple-platforms&quot;</span><span class="p">)</span>
</div></code></pre><p>Pkg-config is a simple yet super-useful BSD mechanism to configure the C/C++ compilers. If you have installed my final brew package for pjproject <code>brew install oliverepper/made/pjproject-apple-platforms</code> you can try it out by typing:</p><pre><code><div class="highlight"><span></span>pkg-config --cflags --libs pjproject-apple-platforms
</div></code></pre><p>What you receive as output can be passed to a C/C++ compiler on the command-line. Let's make an example.</p><h3>Example program in ObjC</h3><p>Create the program</p><pre><code><div class="highlight"><span></span>cat <span class="s">&lt;&lt; EOF &gt; pjsip-test.m</span>
<span class="s">#define PJ_AUTOCONF 1</span>

<span class="s">#include &lt;pjsua.h&gt;</span>

<span class="s">int main()</span>
<span class="s">{</span>
<span class="s">	pj_init();</span>

<span class="s">	return 0;</span>
<span class="s">}</span>
<span class="s">EOF</span>
</div></code></pre><p>compile it for macOS</p><pre><code><div class="highlight"><span></span>clang -isysroot <span class="k">$(</span>xcode-select -p<span class="k">)</span>/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk <span class="sb">`</span>pkg-config --libs --cflags pjproject-apple-platforms<span class="sb">`</span> -o pjsip-test pjsip-test.m
</div></code></pre><p>It should give you the following output:</p><pre><code><div class="highlight"><span></span><span class="mi">08</span><span class="p">:</span><span class="mi">40</span><span class="p">:</span><span class="mf">15.580</span>         <span class="n">os_core_unix</span><span class="p">.</span><span class="n">c</span> <span class="o">!</span><span class="n">pjlib</span> <span class="mf">2.12</span> <span class="k">for</span> <span class="n">POSIX</span> <span class="n">initialized</span>
</div></code></pre><p>You can compile it for the iPhone simulator running on Apple Silicon like this:</p><pre><code><div class="highlight"><span></span>clang -isysroot /Applications/Xcode-13.3.1.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk <span class="sb">`</span>pkg-config --libs --cflags pjproject-apple-platforms-iPhoneSimulator<span class="sb">`</span> -o pjsip-test pjsip-test.m
</div></code></pre><h3>SPM</h3><p>Back to the <code>systemLibrary</code>-target we're still missing the translation between C-style header files and Swift modules. This can be achieved via the following <code>module.modulemap</code>:</p><pre><code><div class="highlight"><span></span><span class="n">module</span> <span class="n">Cpjproject</span> <span class="p">[</span><span class="n">system</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s">&quot;shim.h&quot;</span>
<span class="p">}</span>
</div></code></pre><p>and the shim header:</p><pre><code><div class="highlight"><span></span><span class="cp">#define PJ_AUTOCONF 1</span>
<span class="cp">#include</span> <span class="cpf">&lt;pjsua.h&gt;</span><span class="cp"></span>
</div></code></pre><h3>Wrapper or test target</h3><p>Now we can create other targets in our swift package that can depend on <code>Cpjproject</code> and the will "see" all of pjproject from within Swift. All is great as long as we only build for the Mac!</p><h2>Other target</h2><p>Once we try to build the swift package for other platforms (iPhoneOS, iPhoneSimulator) the pkg-config file configures the linker to load the version of <code>libpjproject.a</code> that was build for macOS which will then fail.</p><h3>The trick</h3><p>I made another pkg-config file called <code>pjproject-apple-platforms-SPM</code> that intentially gives no path to the libraries so using <code>-lpjproject</code> would fail.</p><pre><code><div class="highlight"><span></span><span class="p">.</span><span class="n">systemLibrary</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;Cpjproject&quot;</span><span class="p">,</span> <span class="n">pkgConfig</span><span class="p">:</span> <span class="s">&quot;pjproject-apple-platforms-SPM&quot;</span><span class="p">)</span>
</div></code></pre><p>Swift package has another target type that can do the rescue, here:</p><pre><code><div class="highlight"><span></span><span class="p">.</span><span class="n">binaryTarget</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;libpjproject&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="s">&quot;libpjproject.xcframework&quot;</span><span class="p">)</span>
</div></code></pre><p>A binary target understands xcframeworks and copies the right libraries into place just before the build. This enables the linker to find the appropriate library for <code>-lpjproject</code>.</p><h2>Final</h2><p>Finally create a third target:</p><pre><code><div class="highlight"><span></span><span class="p">.</span><span class="n">target</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;PJSIP&quot;</span><span class="p">,</span> <span class="n">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;Cpjproject&quot;</span><span class="p">,</span><span class="s">&quot;libpjproject&quot;</span><span class="p">])</span>
</div></code></pre><p>that you can use to give PjSIP project a nice sift interface. Something like <code>func pjInit() throws</code> and so on.</p><p>What we have achieved now ist that you can work on the swift package in isolation and have executable targets for integration tests, test targets for unit tests and once you use the swift package in a multiplatform app everything is automatically configured for you. Pretty neat :-D</p><h3>Links</h3><ul><li><a href="https://github.com/oliverepper/homebrew-made">brew package</a></li><li><a href="https://github.com/oliverepper/pjproject-apple-platforms-Demo">demo App</a></li></ul></article></div></main><footer><div class="container"><div class="credits">Oliver Epper &middot; made with <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a> &middot;  inspired by <a href="https://github.com/luizdepra/hugo-coder" target="_blank">Coder</a> &middot; <a href="/feed.rss">RSS feed</a></div></div></footer></div><script src="https://kit.fontawesome.com/fd7cbf6928.js" crossorigin="anonmous"></script></body></html>