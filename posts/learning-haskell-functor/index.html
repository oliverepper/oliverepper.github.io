<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="oliep"/><link rel="canonical" href="https://oliver-epper.de/posts/learning-haskell-functor"/><meta name="twitter:url" content="https://oliver-epper.de/posts/learning-haskell-functor"/><meta name="og:url" content="https://oliver-epper.de/posts/learning-haskell-functor"/><title>Learning Haskell – Functors | oliep</title><meta name="twitter:title" content="Learning Haskell – Functors | oliep"/><meta name="og:title" content="Learning Haskell – Functors | oliep"/><meta name="description" content="Build your own functor typeclass and a few conforming types"/><meta name="twitter:description" content="Build your own functor typeclass and a few conforming types"/><meta name="og:description" content="Build your own functor typeclass and a few conforming types"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to oliep"/></head><body><div class="wrapper"><header><div class="container"><nav class="navigation"><a href="/">oliep</a><ul><li><a href="/posts">Posts</a></li><li><a href="/apps">Apps</a></li><li><a href="https://golf.oliver-epper.de">Golf</a></li><li><a href="/about">About</a></li></ul></nav></div></header><main class="grow"><div class="container"><article><h1>Learning Haskell – Functors</h1><div class="item-metadata"><ul><li><span class="fas fa-calendar"></span>18. August 2024</li><li><span class="fas fa-clock"></span>4-minute read</li></ul><div class="taglist"><span class="fas fa-tags"></span><a href="/tags/haskell">Haskell</a>&middot;<a href="/tags/functor">Functor</a></div></div><p><em>Disclaimer: This content comes straight out of the fantastic book <a href="https://effective-haskell.com">Effective Haskell</a> written by <a href="https://rebeccaskinner.net">Rebecca Skinner</a>. I was only talking notes and doing my own little experiments. Original Haskell content by me will follow shortly.</em></p><p>I am learning Haskell and I am having great fun with it. My goal is to be able to apply <a href="https://www.typetheoryforall.com/episodes/denotational-design">Denotational Design</a> as described by <a href="http://conal.net">Conal Elliott</a> to the software I build and learning Haskell gives me a better understanding of the fundamentals, through practice.</p><p>I believe that the programming language you work in influences the way you think, so I make a real effort to be fluent in multiple languages with different paradigms.</p><h1>Functor</h1><p>For the mathematical definition of functor see <a href="https://en.wikipedia.org/wiki/Functor#Definition">Wikipedia</a>.</p><p>In programming a functor is a thing that knows how to apply a function to a certain structure preserving that structure. The functor does this via the <code>fmap</code> function that the typeclass <code>Functor</code> describes:</p><p><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p><p>Read this as: With a function from a to b and a functor of a it returns a functor of b.</p><p>There is another function <code>&lt;$</code> in the functor typeclass that is called replace:</p><p><code>(&lt;$) :: a -&gt; f b -&gt; f a</code></p><p>Imagine the function you want to apply to the functor always returns the same value then the signature becomes clear: With a constant value a and a functor of b it returns a functor of a.</p><p>This can always be expressed with <code>fmap</code> giving it <code>const</code> as it's function.</p><p>Let build our own Functor typeclass in Haskell:</p><pre><code><div class="highlight"><span></span><span class="kr">class</span><span class="w"> </span><span class="kt">MyFunctor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">myFMap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="n">myReplace</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="n">myReplace</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myFMap</span><span class="w"> </span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">f</span>
</div></code></pre><p>As mentioned myReplace is already implemented for every instance of out MyFunctor class.</p><h2>List</h2><p>To see this in action let's build something simple as our structure like a list:</p><pre><code><div class="highlight"><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">MyList</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span>
</div></code></pre><p>This is your standard recursive list data structure. Let's make it an instance of MyFunctor:</p><pre><code><div class="highlight"><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">MyFunctor</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">myFMap</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span>
<span class="w">  </span><span class="n">myFMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">MyList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">rest</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">myFMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">rest</span><span class="p">)</span>
</div></code></pre><p>There you have it. Now let's invent infix operators for <code>myFMap</code> and <code>myReplace</code> and try them out:</p><pre><code><div class="highlight"><span></span><span class="kr">infixl</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;.&gt;</span>
<span class="p">(</span><span class="o">&lt;.&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myFMap</span>

<span class="kr">infixl</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;.</span>
<span class="p">(</span><span class="o">&lt;.</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">myReplace</span>

<span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;.&gt;</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">Empty</span><span class="w">         </span><span class="c1">-- Mylist 2 Empty</span>
<span class="mi">99</span><span class="w"> </span><span class="o">&lt;.</span><span class="w"> </span><span class="kt">Empty</span><span class="w">                     </span><span class="c1">-- Empty</span>
<span class="mi">99</span><span class="w"> </span><span class="o">&lt;.</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="kt">MyList</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kt">Empty</span><span class="p">)</span><span class="w"> </span><span class="c1">-- MyList 99 (MyList 99 Empty)</span>
</div></code></pre><p>So you see the Functor instance of our MyList can apply a function to every element preserving the structure of the MyList. The function can change the type of the element but it will always be a list with the same number of elements:</p><pre><code><div class="highlight"><span></span><span class="nf">show</span><span class="w"> </span><span class="o">&lt;.&gt;</span><span class="w"> </span><span class="kt">MyList</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">Empty</span><span class="w">         </span><span class="c1">-- MyList &quot;1&quot; Empty</span>
</div></code></pre><h2>Maybe</h2><p>Let's build another structure that can implement the Functor typeclass. I will use German words for the type name and the constructors because just like <code>List Maybe</code> already is an instance of <code>Functor</code> and although we will implement <code>MyFunctor</code> I think it makes it clearer:</p><pre><code><div class="highlight"><span></span><span class="n">data</span> <span class="n">Vielleicht</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Nix</span> <span class="o">|</span> <span class="n">Ein</span> <span class="n">a</span> <span class="n">deriving</span> <span class="n">Show</span>

<span class="n">instance</span> <span class="n">MyFunctor</span> <span class="n">Vielleicht</span> <span class="k">where</span>
  <span class="n">myFMap</span> <span class="kc">_</span> <span class="n">Nix</span> <span class="p">=</span> <span class="n">Nix</span>
  <span class="n">myFMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">Ein</span> <span class="n">a</span><span class="p">)</span> <span class="p">=</span> <span class="n">Ein</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</div></code></pre><p>Since <code>MyList</code> and <code>Vielleicht</code> are of the same kind: <code>* -&gt; *</code> that means both taking one parameter to construct a type this was pretty mechanic. Nothing new, here.</p><h2>Either</h2><p>I am using German words again to build an <code>Either</code> type that has the kind: <code>* -&gt; * -&gt; *</code>. This means the type constructor will need two parameters to construct a type.</p><pre><code><div class="highlight"><span></span><span class="n">data</span> <span class="n">Entweder</span> <span class="n">a</span> <span class="n">b</span> <span class="p">=</span> <span class="n">Links</span> <span class="n">a</span> <span class="o">|</span> <span class="n">Rechts</span> <span class="n">b</span> <span class="n">deriving</span> <span class="n">show</span>
</div></code></pre><p>We can use that to build a save division function:</p><pre><code><div class="highlight"><span></span><span class="nf">teile</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Fractional</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Entweder</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="n">a</span>
<span class="nf">teile</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Links</span><span class="w"> </span><span class="s">&quot;NaN&quot;</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rechts</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span>
</div></code></pre><p>Now let's think about the Functor instance for <code>Entweder</code>. I might want to pass <code>round</code> to the result of <code>teile</code> but that only needs to be done if the result is an instance of <code>Rechts</code>. I don't want to <code>round</code> the String.</p><p>So we can implement a sane Functor instance like this:</p><pre><code><div class="highlight"><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">MyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">Entweder</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">myFMap</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">(</span><span class="kt">Links</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Links</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="w">  </span><span class="n">myFMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Rechts</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rechts</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
</div></code></pre><p>Let's try it out:</p><pre><code><div class="highlight"><span></span><span class="n">round</span> <span class="o">&lt;</span><span class="p">.</span><span class="o">&gt;</span> <span class="n">teile</span> <span class="mi">5</span> <span class="mi">2</span>     <span class="o">--</span> <span class="n">Rechts</span> <span class="mi">2</span>
</div></code></pre><h1>Functions</h1><p>Rebecca shows something else that is cool. Let's create a wrapper for a function so that we can show that even a function can be a functor:</p><pre><code><div class="highlight"><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Funktion</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Funktion</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">MyFunctor</span><span class="w"> </span><span class="p">(</span><span class="kt">Funktion</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">myFMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Funktion</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Funktion</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>

<span class="nf">run</span><span class="w"> </span><span class="p">(</span><span class="n">show</span><span class="w"> </span><span class="o">&lt;.&gt;</span><span class="w"> </span><span class="kt">Funktion</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="c1">-- &quot;13&quot; the type is String, now</span>
</div></code></pre><p>Type <code>:i Functor</code> in ghci and you can see that <code>(-&gt;) r</code> is indeed a <code>Functor</code> instance. In hindsight this seems obvious. The functor knows how to apply a function f to the result of the function g and gives you a new function f after g – thus the structure is maintained.</p></article></div></main><footer><div class="container"><div class="credits">Oliver Epper &middot; made with <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a> &middot;  inspired by <a href="https://github.com/luizdepra/hugo-coder" target="_blank">Coder</a> &middot; <a href="/feed.rss">RSS feed</a></div></div></footer></div><script src="https://kit.fontawesome.com/fd7cbf6928.js" crossorigin="anonmous"></script></body></html>